<!-- TEST 13:10 -->
<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Einfaches Tetris</title>
<style>
  body {
    background: #000;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
  }
  canvas {
    background: #111;
    display: block;
  }
</style>
</head>
<body>
<canvas id="tetris" width="240" height="480"></canvas>
<script>
const canvas = document.getElementById('tetris');
const context = canvas.getContext('2d');
context.scale(24,24); // jeder Block 24px

const arena = createMatrix(10,20); // 10x20 Spielfeld

// Tetrominos Formen
const tetrominos = {
  'I': [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
  'O': [[2,2],[2,2]],
  'T': [[0,3,0],[3,3,3],[0,0,0]],
  'S': [[0,4,4],[4,4,0],[0,0,0]],
  'Z': [[5,5,0],[0,5,5],[0,0,0]],
  'J': [[6,0,0],[6,6,6],[0,0,0]],
  'L': [[0,0,7],[7,7,7],[0,0,0]],
};

function createMatrix(w,h){
  const matrix = [];
  while(h--) matrix.push(new Array(w).fill(0));
  return matrix;
}

function drawMatrix(matrix, offset){
  matrix.forEach((row,y)=>{
    row.forEach((value,x)=>{
      if(value!==0){
        context.fillStyle = colors[value];
        context.fillRect(x+offset.x, y+offset.y, 1,1);
      }
    });
  });
}

function merge(arena, player){
  player.matrix.forEach((row,y)=>{
    row.forEach((value,x)=>{
      if(value!==0) arena[y+player.pos.y][x+player.pos.x] = value;
    });
  });
}

function collide(arena, player){
  const [m,o] = [player.matrix, player.pos];
  for(let y=0; y<m.length; y++){
    for(let x=0; x<m[y].length; x++){
      if(m[y][x]!==0 &&
        (arena[y+o.y] && arena[y+o.y][x+o.x])!==0){
        return true;
      }
    }
  }
  return false;
}

function rotate(matrix){
  // 90Â° drehen
  for(let y=0; y<matrix.length; y++){
    for(let x=0; x<y; x++){
      [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
    }
  }
  matrix.forEach(row => row.reverse());
}

function playerReset(){
  const pieces = 'ILJOTSZ';
  player.matrix = JSON.parse(JSON.stringify(tetrominos[pieces[pieces.length*Math.random()|0]]));
  player.pos.y = 0;
  player.pos.x = (arena[0].length/2|0) - (player.matrix[0].length/2|0);
  if(collide(arena, player)){
    arena.forEach(row=>row.fill(0));
  }
}

function playerDrop(){
  player.pos.y++;
  if(collide(arena, player)){
    player.pos.y--;
    merge(arena, player);
    playerReset();
  }
  dropCounter = 0;
}

function playerMove(dir){
  player.pos.x += dir;
  if(collide(arena, player)) player.pos.x -= dir;
}

function playerRotate(){
  const pos = player.pos.x;
  rotate(player.matrix);
  let offset = 1;
  while(collide(arena, player)){
    player.pos.x += offset;
    offset = -(offset + (offset>0?1:-1));
    if(offset>player.matrix[0].length){
      rotate(player.matrix);
      rotate(player.matrix);
      rotate(player.matrix);
      player.pos.x = pos;
      return;
    }
  }
}

function arenaSweep(){
  outer: for(let y=arena.length-1; y>=0; y--){
    if(arena[y].every(val=>val!==0)){
      arena.splice(y,1);
      arena.unshift(new Array(arena[0].length).fill(0));
      y++;
    }
  }
}

function draw(){
  context.fillStyle = '#111';
  context.fillRect(0,0,canvas.width,canvas.height);
  drawMatrix(arena,{x:0,y:0});
  drawMatrix(player.matrix, player.pos);
}

let dropCounter = 0;
let dropInterval = 1000;
let lastTime = 0;

function update(time=0){
  const deltaTime = time - lastTime;
  lastTime = time;
  dropCounter += deltaTime;
  if(dropCounter > dropInterval){
    playerDrop();
  }
  arenaSweep();
  draw();
  requestAnimationFrame(update);
}

document.addEventListener('keydown', event => {
  switch(event.key){
    case 'ArrowLeft': playerMove(-1); break;
    case 'ArrowRight': playerMove(1); break;
    case 'ArrowDown': playerDrop(); break;
    case 'ArrowUp': playerRotate(); break;
  }
});

const colors = [
  null,
  '#00f0f0', // I
  '#f0f000', // O
  '#a000f0', // T
  '#00f000', // S
  '#f00000', // Z
  '#0000f0', // J
  '#f0a000', // L
];

const player = {
  pos: {x:0,y:0},
  matrix: null,
};

playerReset();
update();
</script>
</body>
</html>
